# -*- coding: utf-8 -*-
"""Lab3_extension.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HLiA6snuX8Lbl0qB1o4J261cz0fjU8sc
"""

import numpy as np
from matplotlib import pyplot as plt
from scipy.stats import truncnorm
import pandas as pd
import seaborn as sns
from scipy.stats import t
import math

#small value to avoid divisions by 0 when std_e or std_s assume this value
eps = 1e-30

def Peergrading_simulation(H, S, K, std_s, std_e, corruption_rate, integrity_rate, seed, output = False, verbose = False, return_acc= False):
  
  #fix the random seed
  np.random.seed(seed)

  #Initialization phase

  #sample S students quality from a uniform distribution with support [0,1]
  X = np.random.uniform(size = S)

  #Delivery phase
  Q = np.empty(shape = (H,S))
  
  for s, x in enumerate(X):
    #generating the extremes to insert in stats.truncnorm in order to get a truncate normal with support [0,1]
    a, b = (0 - x) / (std_s + eps), (1 - x) / (std_s + eps)
    #sample H values from the truncated norm: these are the homework qualities
    Q[:, s] = truncnorm(a, b, loc = x, scale = std_s).rvs(H)

  #Evaluation phase
  E = np.empty(shape = (H,S,K))
  for h in range(H):
    for s in range(S):
      #generating the extremes to insert in stats.truncnorm in order to get a truncate normal with support [0,1]
      a, b = (0 - Q[h, s]) / (std_e + eps), (1 - Q[h, s]) / (std_e + eps)
      for k in range(K):
        corrupt = np.random.uniform() < corruption_rate
        accept = np.random.uniform() < integrity_rate
        if corrupt and not accept:
          #sample a value (an evaluation) from the truncated norm and increase the mark, but it cannot exceed 1
          E[h, s, k] = min(truncnorm(a, b, loc = Q[h, s], scale = std_e).rvs(1) + 0.2, 1)
        else:
          #sample a value (an evaluation) from the truncated norm
          E[h, s, k] = truncnorm(a, b, loc = Q[h, s], scale = std_e).rvs(1) 

  #average on the evaluations
  Q_estimated = E.mean(axis = 2)


  #Accuracy computation
  rel_err = np.sum(np.abs(Q_estimated - Q), axis = 0)/np.sum(Q, axis = 0)
  avg_rel_err = np.mean(rel_err)
  acc = 1 - avg_rel_err
  
  #Saving results
  stats = pd.DataFrame([[acc, H, S, K, std_s, std_e, corruption_rate, integrity_rate, seed]])
  stats.to_csv(output, index=False, header = False, mode='a', sep = " ")

  if verbose:
    print("Accuracy: ", acc)
    print(H, S, K, std_s, std_e, seed)

#Define inputs 
H = 5
S = 32
K = 8
std_s = 0.1
std_e = 0.1
SEED =  range(2, 8)
CORR_RATES = np.linspace(start = 0.2, stop = 1, num=5)
INTG_RATES = np.linspace(start = 0, stop = 1, num=6)

# for corruption_rate in CORR_RATES:
#   for integrity_rate in INTG_RATES:
#     for seed in SEED:
#       Peergrading_simulation(H, S, K, std_s, std_e, corruption_rate, integrity_rate, seed, output = "./Corruption_simulation.csv")

attributes = ["Accuracy", "Number of homeworks", "Number of students", "Number of evaluators", "Homework quality std", "Evaluation std", "Corruption_rate", "Integrity_rate", "Seed"]
stats = pd.read_csv('./Corruption_simulation.csv', sep=' ', names = attributes)

attributes.remove("Seed")
attributes.remove("Accuracy")

#averaging accuracy over runs with different seeds
avg_stats = stats\
.drop(columns = ["Seed"])\
.groupby(attributes)\
.mean()\
.reset_index()

#computing sample std of accuracy over runs with different seeds
avg_stats["Accuracy std"] = stats\
.drop(columns= ["Seed"])\
.groupby(attributes)\
.std(ddof = 1).values

ci_semidepths = []

for avg_acc, acc_std in zip(avg_stats["Accuracy"], avg_stats["Accuracy std"]):
  #comupting confidence intervals
  CI = t.interval(0.90, 5, avg_acc, acc_std)
  #comupting confidence intervals semidepths
  semidepth = (CI[1] - CI[0])/2
  ci_semidepths.append(semidepth)
  
avg_stats["CI semi-depth"] = ci_semidepths

#List of points with equal corruption and integrity rates
key_points = []
for corruption_rate in CORR_RATES:
  key_points.append(avg_stats.loc[(avg_stats['Corruption_rate'] == corruption_rate) & (avg_stats['Integrity_rate'] == corruption_rate), ['Accuracy']].values[0][0])

colors = ["orange", "red", "blue", "purple", "black"] 

fig, ax = plt.subplots(2, 1, figsize = (10, 10), sharex = True)
#creating two graphs for every "corruption rate" value
for c, corruption_rate in zip(colors, CORR_RATES):
  ax[0].set_xlabel("Integrity rate")
  ax[0].set_ylabel("Accuracy")
  ax[0].grid()

  ax[1].set_xlabel("Integrity rate")
  ax[1].set_ylabel("Semi-depth of CI")
  ax[1].grid()
  
  #selecting only the part of the dataframe with the fixed values
  acc_by_corr_rates = avg_stats.loc[(avg_stats["Corruption_rate"] == corruption_rate), ["Accuracy"]]
  CI = avg_stats.loc[(avg_stats["Corruption_rate"] == corruption_rate), ["CI semi-depth"]]

  #plotting accuracy and w.r.t. the integrity rate
  ax[0].plot(INTG_RATES, acc_by_corr_rates, "*-", c = c, label = "Corruption rate: " + str(corruption_rate))
  #plotting confidence intervals semi-depths w.r.t. the integrity rate
  ax[1].plot(INTG_RATES, CI, "*-", c = c, label = "Corruption rate: " + str(corruption_rate))

#highlighting points with the same corruption and integrity rates
ax[0].plot(CORR_RATES, key_points, "--", c = "green", label = "Equal corruption and integrity")

plt.legend()
plt.tight_layout()

plt.savefig('Corr_Intg.png', bbox_inches='tight')

EFF_CORR = []

for corruption_rate in CORR_RATES:
  #Computing "effective corruption index", namely the slope of a corruption line, normalized by its corruption rate
  EFF_CORR.append(((avg_stats.loc[(avg_stats['Corruption_rate'] == corruption_rate) & (avg_stats['Integrity_rate'] == 1), ['Accuracy']].values -
        avg_stats.loc[(avg_stats['Corruption_rate'] == corruption_rate) & (avg_stats['Integrity_rate'] == 0), ['Accuracy']].values)/corruption_rate)[0][0])

#Plotting effective corruption w.r.t. corruption rate
plt.figure()
plt.ylabel("Effective corruption")
plt.xlabel("Corruption rate")
plt.plot(CORR_RATES, EFF_CORR, "*-")
plt.grid()
# plt.savefig('effectiveCorruption.png', bbox_inches='tight')
plt.savefig('Effective corruption.png', bbox_inches='tight')

